(10진수 -> r진수 변환법)
10진수 -> r진수 변환시 몫이 0이 될때까지 r로 나누며(각비트는 r^n r^n-1 ~`r^0까지 구별되므로 나눠가며 각 비트에 나머지를 대입)
소수점 이하의 경우 ^-1, ^-2 이런 방식 => 반대로 곱해가며 각 비트에 정수부분 대입
2진수 -> 8진수는 3자리씩 (2^3 = 8^1이기 때문), 16진수도 이와 비슷함

(덧셈 및 뺄셈 계산법)
피감수의 보수를 취하고 감수와 더해줌 
1. 감수 > 피감수인 경우 -> 올림자리 버리기   2. 감수 < 피감수인 경우 계산 (이후 그에 대해 보수를 취하고 -부호 붙이기- 일반적으로 사용하는 2진수가 나옴)
감소된 기수 보수의 경우 위의 과정과 동일하나 1번의 경우 1을 더해줌(기수 보수의 경우 r^N - N 의 값을 가지나 감소된 기수 보수의 경우 (r^N-1)-N의 값을 가지므로)
*n비트 합 => n+1비트일 때 수를 나타내는 비트수가 부족하면 오버플로우 => 수를 나타내는 비트는 유한하기 때문에 초과된 결과는 나타낼 수 없음.

(2진 코드의 종류)
2진 코드의 종류 1. 가중치 코드(BCD,2421,84-2-1 코드 등)  2.자기 보수화 코드(2421, 3초과 코드 등)
가중치코드는 4자리 비트에서 비트값이 1일 경우 그에 해당하는 자리에 맞는 수를 더함/자기 보수화 코드의 경우 10진수의 9의 보수와 2진 코드의 1의 보수의 10진수 값 동일

(BCD코드와 그레이코드)
BCD코드는 4비트가 10진수의 1비트를 나타냄 -> 사용 비트수가 많아지나 사람은 10진수를 기준으로 하기 때문에 장점이 존재함
BCD코드의 덧셈의 경우 각자리수가 9가 초과 되는 경우 앞4비트로 1을 올리고 0110을 더해줌(BCD코드는 1010~1111 사용을 안하기때문)
그레이 코드의 경우 다음 수로 넘어가는 경우 1자리씩 바뀌어 오류 발생을 줄일 수 있음(0111 -> 1000은 4자리 모두 바꿔야함)

(아스키코드와 짝수 패러티 비트)
아스키코드는 보통 7비트로 정보를 저장하며 1바이트(8비트)룰 이용해 맨왼쪽 비트를 오류검출 비트로 이용할 수 있는데 이를 오류검출 패러티 비트라 함
짝수 패러티 비트, 홀수 패러티 비트는 1바이트의 비트에서의 1의 개수를 짝수, 홀수로 맞춰줌 다만 짝수 개의 오류 비트 발생시 이를 잡아 내지 못함(홀수개 -> 홀수개로 변해도 똑같이 홀수개이기 때문)

(디지털 컴퓨터의 구성부품)
디지털 컴퓨터는 정보를 저장하는 부분(레지스터)과 비트를 처리하는 부분(논리 회로, 연산 회로)으로 나눠짐
레지스터 = 연속된 2진셀(0,1 이라는 두 개의 안정된 상태를 가짐)의 모임, 비트를 처리하진 못하고 정보를 저장하기만 함


(2진 논리)
2진 논리는 변수와 논리 연산으로 구분됨
변수는 0 또는 1의 값을 가지며 논리 연산자의 종류는 다음과 같음
AND(두개 다 1일때만 1), OR(두개 다 0일때만 0), NOT(부정) 등이 존재
타이밍도 가로축: 시간 세로축: 가능한 두 전압 사이를 변경하는 신호
진리표 가능한 모든 변수 조합과 그에 따른 결과를 나타

-----------checklist------------------
[v] 키워드를 보고 그에 대한 설명 가능한가?

