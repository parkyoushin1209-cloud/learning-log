#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int data[100];


void swap(int* a, int* b) {  // call by value => *로 설정해야 data값 변경 가능
	int temp = *a;
	*a = *b;
	*b = temp;
}

//선택 정렬
특징:-가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸기 반복(총 N-1번 반복) => 평균적으로 O(N^2)의 시간 복잡도/ 최선의 경우 거의 정렬되어있는 경우 시간복잡도 O(N)까지 가능
-매번 전체 배열을 돌면서 값끼리 비교 후 가장 작은 값 - 정렬되지 않은 맨 앞 값과 교환
-> 불안정 정렬(안정 정렬은 1차 정렬 후 순서가 유지된 채 2차 정렬)
-추가적인 메모리 사용은 없음 
장점: 교환 횟수가 적다... , 구현은 단순함
단점: 비교 횟수가 많다...
void selections_sort() {
	for (int i = 0; i < 100; i++) {
		int min_index = i;
		for (int j = i + 1; j < 100; j++) {
			if (data[min_index] > data[j])
				min_index = j;
		}
		swap(&data[i], &data[min_index]);
	}
}

//삽입 정렬
특징: 2번째 ~ 마지막 요소값을 잡고 앞 데이터 보다 큰지 작은지 비교 크면 뒤에 삽입 후 종료 작으면 앞에 삽입 후 과정 반복
장점 : 필요한 경우에만 비교 및 swap
단점: 데이터 분포가 최악인 경우 시간 복잡도가 O(N^2) 까지 됨
void insertion_sort() {
	for (int i = 1; i < 100; i++) {
		for (int j = i; j > 0; j--) {
			if (data[j] < data[j - 1])
				swap(&data[j], &data[j - 1]);
			else
				break;// 데이터가 거의 정렬되어 있는 경우 시간 줄어듬(**필요할때만 비교한다의 의미)
		}
	}
}
//퀵 정렬
특징: 기준 데이터 설정후 앞-> 뒤 : 큰 값 찾기 앞 <- 뒤 : 작은 값 찾기 찾은 후 교환 엇갈리면 기준값 <-> 작은 값 swap like 기준점 기준으로 작은 요소 그룹 큰 그룸으로 나눔
단점: 기준 값들이 최댓값들이거나 최솟값들인 경우 시간 복잡도가 O(N^2) 까지 올라감
장점: 2개의 그룹으로 나눠가고 각 단계별 과정이 2배가 됨 -> 시간 복잡도  평균 O(nlogn)  파이썬의 sort()는 nlogn을 보장해줌(Tim sort = Insertions Sort + Merge sort)
void quick_sort(int data[], int start, int end) {
	if (start >= end) // 정렬완료
		return;
	int pivot = start; // 기준 데이터
	int left = start + 1;
	int right = end;
	while (left <= end && data[left] > data[pivot])
		left++;
	while (right > start && data[right] < data[pivot]) // 처음은 정렬돼있다 가정하기 때문에 start < 일때까지만
		right--;
	if (left > right)
		swap(&data[pivot], &data[right]); // 엇갈리면 기준과 right교환 
	else
		swap(&data[left], &data[right]);
	quick_sort(data, start, right - 1);
	quick_sort(data, right + 1, end);
}

//계수 정렬
특징: 특정 조건 만족시 매우 빠름 데이터 수 N개 최댓값 K => O(N+K)
보통 0이상일 때 자주 쓰임 -> 음수일 때는 사용 불가능한가? X 값들에 최솟값을 더한 뒤 마지막에 다시 빼주면 가능 -> 배열의 크기가 많이 늘어남
비교 기반은 아님
장점: 특정 조건 만족시 매우 빠름
단점: 데이터의 스펙트럼이 많아질 경우 메모리 사용량이 매우 많이 늘어남, 소수 값이 있는 경우도 불가능
void counting_sort(int data[],int size) {
	int max = data[0];
	for (int i = 1; i < size; i++) {
		if (max < data[i])
			max = data[i];
	}
	int* count = (int*)calloc((max+1), sizeof(int));

	for (int i = 0; i < size; i++)
		count[data[i]]++;

	for (int i = 0; i <= max; i++) {
		int c = count[i];
        while(c--)// 변수 이름 다르게 가져가기*******
        printf("%d ",i);
	}

	free(count);
}

int main() {
	for (int i = 0; i < 100; i++) 
		data[i] = i + 1;
	
	return 0;
}

checklist
[v] 각 정렬의 시간복잡도가 변화하는 이유를 설명할 수 있는가?
[v] 각 정렬의 장단점 설명이 가능한가?
[v] 각 정렬의 기본 원리를 이해하고 있는가?
