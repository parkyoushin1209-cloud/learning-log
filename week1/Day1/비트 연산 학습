#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

void print_binary(int x) {
	for (int i = sizeof(x) * 8; i >= 0; i--) { //sizeof(x) int자료형의 바이트 크기 반환 바이트 = 8비트
		printf("%d", (x >> i) & 1); // i번째 비트 확인
	}
	printf("\n");
}// 파이썬의 경우 bin(x)로 출력

int main() {
	int n = 5;
	printf("%d\n", (n >> 2) & 1); //n의 2번째 비트 확인  & = and 연산 둘 다 1이면 1-> (n 두번째 비트가 1이면 1 0이면 0으로  **비트 추
	n |= (1 << 3); // n의 3번째 비트 1로 | = or연산 하나만 1이면 1=> n의 3번째 비트가 1이됨
	printf("%d\n", n);
	int mask = 0x0F;  
	int value = mask & 40; // 하위 4비트 출력 <= 16진수 F는 1111이고 &로 비트 추출 가능 => 상위 비트는 0을 만나 0이 됨
	printf("%d\n", value);
	value = (value << n); //value = value *= 2^n // 곱셈도 가능 << 한칸이 *2 => n칸은 2^n
	printf("%d\n", value);
	print_binary(value);
	value |= (1 << 0); // 0번째 비트 추가 +1 
	printf("%d\n", value);
	value = (value >> 4); // value = value / 2^4 4번째 비트 미만의 값은 전부 버려짐
	printf("%d\n", value);
	value ^= (1 << n);// n번째 비트 반전 서로 다를 경우만 1임 (1<<n)이 1일 경우 0, 0일 경우 1   **비트 토글
    value &= ~(1 << n) **비트클리어: n번째 비트 0으로
}
//파이썬도 위와 동일함
// & : AND 둘다 1-> 1 | : OR 하나만 1이어도 1 ^ : XOR 서로 다르면 1  :~x (음수)-x = ~x+1(2의 보수) << : 우측 시프트 오른쪽 이동 + 0채우기 >> : 좌측 시프트 좌측으로 이동
>> 의 경우 산술 시프트 : 최상의 비트를 1로 유지하며 음수 유지 /  논리 시프트:0으로 채우며 값이 달라짐
//
