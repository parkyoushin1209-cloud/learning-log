(부울 대수의 구성 조건)
1. 집합에 속함  2. 2진 연산에 관한 규칙 충족   3. 6개의 헌팅턴 공준 만족
---헌팅턴 공준---
1. a. +에 대해 닫혀 있음(닫힘 => 두 원소에 대한 계산 결과가 그 집합 내에 포함 되있음)  b. *에 대해 닫혀있음(1*1=1,0*0=0 등)
2. a. +의 항등원은 0 => + 0 은 아무런 영향 없음  b. *의 항등원은 1이다. 0*1=0, 1*1 = 1 원래 값 유지됨
3. a. + 에 관해 교환적이다 A + B = B + A  b. *에 관해 교환적이다.
4. a. *는 +에 관해 분배적이다 A*(B+C) = (A*B) + (A*C)  b. +는 *에 관해 분배적이다 A+(B*C) = (A+B) * (A+C) 일반적인 대수와 다름
5. 집합 내 원소 x에 대해 a. x+x' = 1 b. x*x`=0 을 만족하는 x`이 집합 내 존재 => 보수 관계
6. x!=y인 조건을 만족하는 원소가 집합 내 존재한다. 0, 1

---정리---
1. x + x = x, x * x = x     2. x + 1 = 1, x * 0 = 0   3. 보수의 보수 존재 (x`)` = x   4. 각 연산에 대해 결합적이다. 5. 드모르간 법칙(x+y)` = x` * y` (x`y`)` = x + y
6. 흡수 x+xy = x, y + xy = y

쌍대 : 2진 연산자를 바꾸고 항등원을 바꿔줌 => 부울 함수의 변수의 보수를 취하지는 않음 위의 a - b 전환됨
부울 함수의 보수 => 쌍대 구함 + 변수의 보수 취함

(부울 함수 구하는 법)
부울 함수 구하는 법 -> 진리표에의 결과가 1인 항(최소항, 표준곱-m)들을 OR 연산 또는 0인 결과(최대항, 표준합-M)에 AND연산 
최소항에서 0인 변수는 ` 1인 변수는 그대로 최대항은 그 반대 따라서 변수의 10진 값이 같을 경우 보수관계 성립 + 최소항은 AND 최대항은 OR연산 쓰므로

(표준 형식과 정준 형식)
정준 형식 -> 최소항의 합 또는 최대항의 곱으로 나타낸 형식 정준 형식 -> 합의 곱 또는 곱의 합 2-레벨 구현 가능
n 레벨 구현에서 n이 작을 경우 게이트간 지연 시간 줄어듬 -> 고속회로에 유리함
반대로 크다면 fan-in 이 늘어남 -> 물리적으로 더 큰 게이트 필요, 입력 커패시턴스 증가 -> 전력 소모 및 지역 속도가 늘어남(부울 대수의 구성 조건)
1. 집합에 속함  2. 2진 연산에 관한 규칙 충족   3. 6개의 헌팅턴 공준 만족
---헌팅턴 공준---
1. a. +에 대해 닫혀 있음(닫힘 => 두 원소에 대한 계산 결과가 그 집합 내에 포함 되있음)  b. *에 대해 닫혀있음(1*1=1,0*0=0 등)
2. a. +의 항등원은 0 => + 0 은 아무런 영향 없음  b. *의 항등원은 1이다. 0*1=0, 1*1 = 1 원래 값 유지됨
3. a. + 에 관해 교환적이다 A + B = B + A  b. *에 관해 교환적이다.
4. a. *는 +에 관해 분배적이다 A*(B+C) = (A*B) + (A*C)  b. +는 *에 관해 분배적이다 A+(B*C) = (A+B) * (A+C) 일반적인 대수와 다름
5. 집합 내 원소 x에 대해 a. x+x' = 1 b. x*x`=0 을 만족하는 x`이 집합 내 존재 => 보수 관계
6. x!=y인 조건을 만족하는 원소가 집합 내 존재한다. 0, 1

---정리---
1. x + x = x, x * x = x     2. x + 1 = 1, x * 0 = 0   3. 보수의 보수 존재 (x`)` = x   4. 각 연산에 대해 결합적이다. 5. 드모르간 법칙(x+y)` = x` * y` (x`y`)` = x + y
6. 흡수 x+xy = x, y + xy = y

쌍대 : * <-> +, 0 <-> 1 위의 a - b 전환됨
부울 함수의 보수 => 쌍대 구함 + 변수의 보수 취함


(부울 함수 구하는 법)
부울 함수 구하는 법 -> 진리표에의 결과가 1인 항(최소항, 표준곱-m)들을 OR 연산 또는 0인 결과(최대항, 표준합-M)에 AND연산 
최소항에서 0인 변수는 ` 1인 변수는 그대로 최대항은 그 반대 따라서 변수의 10진 값이 같을 경우 보수관계 성립 + 최소항은 AND 최대항은 OR연산 쓰므로
최대항의 곱 => OR항으로 전환후 누락 변수 xx` OR 처리 최소항의 합 => AND항으로 바꾸고 누락 변수 (x+x`) AND처리  

(표준 형식과 정준 형식)
정준 형식 -> 최소항의 합 또는 최대항의 곱으로 나타낸 형식 정준 형식 -> 합의 곱 또는 곱의 합 2-레벨 구현 가능
n 레벨 구현에서 n이 작을 경우 게이트간 지연 시간 줄어듬 -> 고속회로에 유리함
반대로 크다면 fan-in 이 늘어남 -> 물리적으로 더 큰 게이트 필요, 입력 커패시턴스(모든 입력의 커패시턴스를 합쳐서 구함)  증가 -> 전력 소모 증가 및 전 지연
실제 회로에서 어떻게 해결하는가? 
1. 4-input 대신 2-input 여러개 -> 직렬 트랜지스터 줄어듬 저항도 같이 줄어듬  2. 버퍼 삽입 -> 전파 속도 키움 3. 논리 재구성 -> 위의 공준과 정리로 식 간결히 가능 -> 입력 수 감소->커패시턴스 감소 4. 트랜지스터 사이즈 최적화 = 체날폭 증기-> 저항 감소 but 입력, 출력 커패시턴스 등이 증가 따라서 적절한 조화 필요
-> 각각의 상황별 어떻게 변화하는지 학습 필요, 전력

(정논리와 부논리)
쉽게 말해 정논리는 1에 높은 수준의 신호 값 부여 부논리는 0에 높은 수준의 신호 값 부여 -> 논리값은 전압에 논리값을 어떻게 할당할까의 문제임
부논리 회로 그림에는 극성 표시자 필수

(기타)
AND, OR, XOR (교환 결합 가능) / NAND, NOR(교환만 가능)/ 전이, NOT (둘 다 불가능) -> 보수가 들어가는 연산들의 경우 결합이 불가능하다고 생각하기
실제 회로에는 NAND와 NOR이 더 많이 쓰인다 함 -> 트랜지스터로 제작하기 쉽고, 회로 구현이 간편함 특히 NAND 범용게이트 모든 논리 회로 구현 가능 NOR도 가능하나 CMOS에서는 NAND가 더 효과적이라 함
-> ******NAND로 논리 구현해보기
CMOS 구현이 쉬움, 병렬 PMOS + 직렬 NMOS   -- 면적, 지연, 전력 측면에서 유리 -> *****cmos, pmos, nmos에 대해 추가 학습 필요  XOR 은 트랜지스터 수 많고 지연 큼 -> 필요한 곳(가산기, 비교기에만 사용)

checklist
[x] 전력 소모 및 증가에 관한 방법에 대해 왜 그렇게 되는지 이해할 수 있는가? -> 3일차 물리 서적에서 전력레 관한 내용 추가 학습 필요함, 병렬 직렬에 대한 장단점도 복습 필요 
[x] CMOS, PMOS, NMOS가 각각 무엇이진 설명가능한가? -> 추가 학습
[v] 헌팅턴 공준을 통해 여러가지 정리들을 유도해 낼 수 있는가?
