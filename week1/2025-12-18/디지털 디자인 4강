조합회로: 현재의 입력만의 회로 / 순차회로: 논리게이트 + 저장회로(이전 입력에 대한 함수)

조합 회로의 종류
1.반가산기/ 전가산기
반가산기 s =  x^y, c = xy(2개 비트 합산 수행)
전가산기 - 반가산기 2개로 만들기 가능 s = x^y^z , c =xy+yz+zx(3개 비트 합산 수행)

2. 2진 감-가산기:
덧셈의 경우 최하의 비트의 캐리는 0 뺄셈의 경우 1 -> 뺄셈의 경우 2의 보수를 더하는 형식이므로, 피감수의 각 비트와 1에 대해 XOR시 비트 반전 + 캐리에 1 넣어서 2의 보수 만듬
n비트 감-가산의 경우 n개 전가산기 또는 n-1개 전가산기 + 1개 반가산기 필요
오버플로의 경우 부호가 있는 수의 경우 부호 비트로 들어가고 나오는 캐리 비트가 다르면 오버플로 발생한 것 부호 없는 수의 경우 마지막 캐리 비트로 판단

3. 10진 가산기(BCD 코드 이용):
4비트 가산기 필요 두 비트의 합이 19까지 가능(9+9+1[캐리비트]) 10011 ~ 00000까지 kz(8)z(4)z(2)z(1)z(0) 계산 결과가 10이상 -> 0110 추가해줌 
이때 C = k + z(8)z(4) + z(8)z(2) (16이상인 경우 k = 1, 10 ~ 15는 뒤의 항으로 처리 가능)

4. 2진 곱셈기:
승수의 비트와 피승수의 비트를 각각 곱해서 더해줌 피승수의 비트 자리 올라가면 곱셈 결과도 1칸 올려서 적어줌(산술적인 곱셈 방식과 비슷)
-> k비트 승수, j 비트 피승수인 경우 ->  k*j개의 AND연산자 필요 + (j-1)(k) 비트 가산기 필요

5. 크기 비교기:
x(i) = xy + x`y`(등가) 각각의 비트에 대해 x(i)의 값이 전부 0인 경우 A=B
A > B 인 경우 A(n)B`(n) + x(n)A(n-1)B`(n-1) + ..... A < B인 경우 보수 보후를 B로 붙임

6. 디코더:
n - to - m(<=2^n) 라인 -> n 개의 입력을 받고 2^n개의 출력중 적절한 값 출력(이 값들은 최소항들로 이루어짐) => OR게이트를 연결함으로서 부울 함수 구현 가능
함수 값을 1로 만드는 최소항의 수가 2^n-1개 보다 많은 경우 0인거 NOR(x + y)` => 문자 보수 + OR => AND = 원래 함수 최소항 처리 후 NOR 2번 사용해 OR처리

7. 인코더:
보통 2^n개의 입력 => n개의 출력
문제점: 1. 두개의 값에 신호가 들어오면 알맞지 않은 값 출력 가능 => 우선순위 줌으로써 해결 2. 아무 신호도 안 들어오는 경우 -> 000일 때랑 동일 => 신호 들어왔는지 확인하는 출력 비트 생성하기

8.멀티플렉서:
선택 제어 신호를 통해 여러 값들 중 하나를 선택해서 출력
다중 비트를 선택하는 회로 구현가능
부울 함수 구현법 -> n개 변수 부울 함수의 경우 n-1개 변수를 선택 입력으로 설정 마지막 남은 변수에 대한 함수 만들기 2열씩 끊어서 함수값과 마지막 입력 변수 값 비교 후 x, x`, 1, 0 중 하나로

9.3-상태 게이트:
논리 0, 1, 고임피던스 상태로 분류됨
고임피던스 상태 => 1. 개방 회로와 같은 동작 => 출력이 끊긴 것처럼 보임 2. 논리적 의미 없음 3. 출력을 입력에 연결해도 아무 영향 없음 => 출력을 단일 라인으로 해도 문제 X
하나의 버퍼만 출력에 연결 나머지는 고임피던스 상태로 두면 됨

checklist:
[v] 각각의 조합회로에 대해 설명가능한가?
[v] 각각의 조합회로의 원리에 대해 알고 간단한 회로도를 그릴 수 있는가?
