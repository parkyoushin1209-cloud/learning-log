논리 합성 = RTL수준 표현을 테크놀로지 라이브러리 등의 툴을 사용해 게이트 수준 넷-리스트로 변환하는 과정
verilog의 ===, !== 등의 연산은 허용 안됨
if-else, case 등은 mux로 파악, for문을 통해 직혛 조합회로 생성 가능, function은 한 개의 출력을 갖는 조합블록으로 합성함, always문은 조합, 순차회로 모두에 사용 가능
지연 정보는 무시함, 면적과 지연 타이밍은 반비례 관계

게이트 수준 넷-리스트와 RTL 표현을 같은 스티뮬러스를 사용해 실행하고 결과가 동일한지 확인하는 과정 = 기능적 검증 이후 타이밍 검증 실시

RTL 표현은 게이트 수준 넷-리스트 설계에 영향을 미침 -> 논리합성 모델링 지침을 지키는 게 중요 ->
1.verilog 코드 작성 스타일 준수
a.신호 변수에 의미 있는 이름 사용 b.상향 하향 에지 트리거 플립플롭 혼용 금지(클럭skew발생가능) c.기본기능블록,  연속적assign문 사용 절충(게이트 수 증가 시 설계속도 감소, 시뮬레이터 효율적)
d. mux 파생(더 나은 제어, 빠른 합성, 테크놀로지에 의존적), if-else/case문 사용(간결한 표현, 테크놀로지 독립 RTL표현 작성 가능)
e. 논리 구조 최적화를 위해 괄호 사용 f.산술 연산자 *, /, % 사용(구현에 큰 비용, 테크놀로지에 독립적), 블록 설계
f. 한 변수에 연속된 여러 번 할당 주의  g.if-else,case문 명확한 정의 case -> default포함 모든 가능한 분기조건 기술

2. 설계 분할
a. 수평 분할 (최적화 목적으로 논리합성도수에 더 작은 블록을 제공하기 위해 비트 조각 사용)
b. 수직 분할 (블록 기능을 더 작은 하위 모듈로 나누기)
c. 설계 구조의 병렬화 (더 빠른 설계를 위해 더 많은 자원 사용, 더 많은 로직 사용 -> 순차적 연산자를 병렬 연산자로 ex. 캐리 룩어헤드 가산기)

3. 설계 제한 명세
